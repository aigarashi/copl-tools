(* false: bool, true: bool, int, bool, string, Value, Exp, Prim, i: int,
   b: bool, x: string, y: string, v: Value, e: Exp, p: Prim, int <: Value,
   bool <: Value, int <: Exp, bool <: Exp, BinOp: Exp[Prim, Exp, Exp],
   If: Exp[Exp, Exp, Exp], Plus: Prim[], Minus: Prim[], Mult: Prim[],
   Lt: Prim[], EvalTo: j[Exp; Value], AppBOp: j[Prim, Value, Value; Value] *)

open MySupport.Error
open MySupport.Pervasives
open Derivation
type value = Value_of_int of int | Value_of_bool of bool
and exp = Exp_of_int of int | Exp_of_bool of bool | BinOp of prim * exp * exp
        | If of exp * exp * exp
and prim = Plus | Minus | Mult | Lt

type judgment = EvalTo of exp * value
              | AppBOp of prim * value * value * value


let rec check_deriv = function
| {conc = _conc_; by = "E-Int"; since = _derivs_; pos = _p_} ->
      (match _conc_ with
         EvalTo(Exp_of_int i, Value_of_int _i) when i = _i && true ->
         (match _derivs_ with
            [] ->
            if true then _conc_
            else errAt _p_ "Wrong rule application: E-Int"
          | _ -> errAt _p_ "The number of premises is wrong: E-Int")
       | _ -> errAt _p_ "The form of conclusion is wrong: E-Int")
| {conc = _conc_; by = "E-Bool"; since = _derivs_; pos = _p_} ->
      (match _conc_ with
         EvalTo(Exp_of_bool b, Value_of_bool _b) when b = _b && true ->
         (match _derivs_ with
            [] ->
            if true then _conc_
            else errAt _p_ "Wrong rule application: E-Bool"
          | _ -> errAt _p_ "The number of premises is wrong: E-Bool")
       | _ -> errAt _p_ "The form of conclusion is wrong: E-Bool")
| {conc = _conc_; by = "E-IfT"; since = _derivs_; pos = _p_} ->
      (match _conc_ with
         EvalTo((If(e1, e2, e3)), v)  ->
         (match _derivs_ with
            [_d1_; _d3_; ] ->
            (match check_deriv _d1_ with
                 EvalTo(_e1, Value_of_bool _b)  ->
                 if _b
                 then (match check_deriv _d3_ with
                           EvalTo(___e2, ___v)  ->
                           if _e1 = e1 && ___v = v && ___e2 = e2 && true
                           then _conc_
                           else errAt _p_ "Wrong rule application: E-IfT"
                       | _ -> errAt _p_ "The form of the third premise is wrong: E-IfT")
                 else errAt _p_ "Wrong rule application: E-IfT"
             | _ -> errAt _p_ "The form of the first premise is wrong: E-IfT")
          | _ -> errAt _p_ "The number of premises is wrong: E-IfT")
       | _ -> errAt _p_ "The form of conclusion is wrong: E-IfT")
| {conc = _conc_; by = "E-IfF"; since = _derivs_; pos = _p_} ->
      (match _conc_ with
         EvalTo((If(e1, e2, e3)), v)  ->
         (match _derivs_ with
            [_d1_; _d3_; ] ->
            (match check_deriv _d1_ with
                 EvalTo(_e1, Value_of_bool _b)  ->
                 if not _b
                 then (match check_deriv _d3_ with
                           EvalTo(___e3, ___v)  ->
                           if _e1 = e1 && ___v = v && ___e3 = e3 && true
                           then _conc_
                           else errAt _p_ "Wrong rule application: E-IfF"
                       | _ -> errAt _p_ "The form of the third premise is wrong: E-IfF")
                 else errAt _p_ "Wrong rule application: E-IfF"
             | _ -> errAt _p_ "The form of the first premise is wrong: E-IfF")
          | _ -> errAt _p_ "The number of premises is wrong: E-IfF")
       | _ -> errAt _p_ "The form of conclusion is wrong: E-IfF")
| {conc = _conc_; by = "E-Plus"; since = _derivs_; pos = _p_} ->
      (match _conc_ with
         EvalTo((BinOp(Plus, e1, e2)), Value_of_int i3)  ->
         (match _derivs_ with
            [_d1_; _d2_; _d3_; ] ->
            (match check_deriv _d1_ with
                 EvalTo(_e1, Value_of_int _i1)  ->
                 (match check_deriv _d2_ with
                      EvalTo(__e2, Value_of_int __i2)  ->
                      (match check_deriv _d3_ with
                           AppBOp(Plus, Value_of_int ___i1,
                                  Value_of_int ___i2, Value_of_int ___i3)
                          ->
                           if _e1 = e1 && __e2 = e2 && ___i1 = _i1 &&
                              ___i2 = __i2 && ___i3 = i3 && true
                           then _conc_
                           else errAt _p_ "Wrong rule application: E-Plus"
                       | _ -> errAt _p_ "The form of the third premise is wrong: E-Plus")
                  | _ -> errAt _p_ "The form of the second premise is wrong: E-Plus")
             | _ -> errAt _p_ "The form of the first premise is wrong: E-Plus")
          | _ -> errAt _p_ "The number of premises is wrong: E-Plus")
       | _ -> errAt _p_ "The form of conclusion is wrong: E-Plus")
| {conc = _conc_; by = "E-Minus"; since = _derivs_; pos = _p_} ->
      (match _conc_ with
         EvalTo((BinOp(Minus, e1, e2)), Value_of_int i3)  ->
         (match _derivs_ with
            [_d1_; _d2_; _d3_; ] ->
            (match check_deriv _d1_ with
                 EvalTo(_e1, Value_of_int _i1)  ->
                 (match check_deriv _d2_ with
                      EvalTo(__e2, Value_of_int __i2)  ->
                      (match check_deriv _d3_ with
                           AppBOp(Minus, Value_of_int ___i1,
                                  Value_of_int ___i2, Value_of_int ___i3)
                          ->
                           if _e1 = e1 && __e2 = e2 && ___i1 = _i1 &&
                              ___i2 = __i2 && ___i3 = i3 && true
                           then _conc_
                           else errAt _p_ "Wrong rule application: E-Minus"
                       | _ -> errAt _p_ "The form of the third premise is wrong: E-Minus")
                  | _ -> errAt _p_ "The form of the second premise is wrong: E-Minus")
             | _ -> errAt _p_ "The form of the first premise is wrong: E-Minus")
          | _ -> errAt _p_ "The number of premises is wrong: E-Minus")
       | _ -> errAt _p_ "The form of conclusion is wrong: E-Minus")
| {conc = _conc_; by = "E-Mult"; since = _derivs_; pos = _p_} ->
      (match _conc_ with
         EvalTo((BinOp(Mult, e1, e2)), Value_of_int i3)  ->
         (match _derivs_ with
            [_d1_; _d2_; _d3_; ] ->
            (match check_deriv _d1_ with
                 EvalTo(_e1, Value_of_int _i1)  ->
                 (match check_deriv _d2_ with
                      EvalTo(__e2, Value_of_int __i2)  ->
                      (match check_deriv _d3_ with
                           AppBOp(Mult, Value_of_int ___i1,
                                  Value_of_int ___i2, Value_of_int ___i3)
                          ->
                           if _e1 = e1 && __e2 = e2 && ___i1 = _i1 &&
                              ___i2 = __i2 && ___i3 = i3 && true
                           then _conc_
                           else errAt _p_ "Wrong rule application: E-Mult"
                       | _ -> errAt _p_ "The form of the third premise is wrong: E-Mult")
                  | _ -> errAt _p_ "The form of the second premise is wrong: E-Mult")
             | _ -> errAt _p_ "The form of the first premise is wrong: E-Mult")
          | _ -> errAt _p_ "The number of premises is wrong: E-Mult")
       | _ -> errAt _p_ "The form of conclusion is wrong: E-Mult")
| {conc = _conc_; by = "E-Lt"; since = _derivs_; pos = _p_} ->
      (match _conc_ with
         EvalTo((BinOp(Lt, e1, e2)), Value_of_bool b3)  ->
         (match _derivs_ with
            [_d1_; _d2_; _d3_; ] ->
            (match check_deriv _d1_ with
                 EvalTo(_e1, Value_of_int _i1)  ->
                 (match check_deriv _d2_ with
                      EvalTo(__e2, Value_of_int __i2)  ->
                      (match check_deriv _d3_ with
                           AppBOp(Lt, Value_of_int ___i1, Value_of_int ___i2,
                                  Value_of_bool ___b3)
                          ->
                           if ___b3 = b3 && _e1 = e1 && __e2 = e2 &&
                              ___i1 = _i1 && ___i2 = __i2 && true
                           then _conc_
                           else errAt _p_ "Wrong rule application: E-Lt"
                       | _ -> errAt _p_ "The form of the third premise is wrong: E-Lt")
                  | _ -> errAt _p_ "The form of the second premise is wrong: E-Lt")
             | _ -> errAt _p_ "The form of the first premise is wrong: E-Lt")
          | _ -> errAt _p_ "The number of premises is wrong: E-Lt")
       | _ -> errAt _p_ "The form of conclusion is wrong: E-Lt")
| {conc = _conc_; by = "B-Plus"; since = _derivs_; pos = _p_} ->
      (match _conc_ with
         AppBOp(Plus, Value_of_int i1, Value_of_int i2, Value_of_int i3)  ->
         (match _derivs_ with
            [] ->
            if i3 = i1 + i2
            then if true then _conc_
                 else errAt _p_ "Wrong rule application: B-Plus"
            else errAt _p_ "Wrong rule application: B-Plus"
          | _ -> errAt _p_ "The number of premises is wrong: B-Plus")
       | _ -> errAt _p_ "The form of conclusion is wrong: B-Plus")
| {conc = _conc_; by = "B-Minus"; since = _derivs_; pos = _p_} ->
      (match _conc_ with
         AppBOp(Minus, Value_of_int i1, Value_of_int i2, Value_of_int i3)  ->
         (match _derivs_ with
            [] ->
            if i3 = i1 - i2
            then if true then _conc_
                 else errAt _p_ "Wrong rule application: B-Minus"
            else errAt _p_ "Wrong rule application: B-Minus"
          | _ -> errAt _p_ "The number of premises is wrong: B-Minus")
       | _ -> errAt _p_ "The form of conclusion is wrong: B-Minus")
| {conc = _conc_; by = "B-Mult"; since = _derivs_; pos = _p_} ->
      (match _conc_ with
         AppBOp(Mult, Value_of_int i1, Value_of_int i2, Value_of_int i3)  ->
         (match _derivs_ with
            [] ->
            if i3 = i1 * i2
            then if true then _conc_
                 else errAt _p_ "Wrong rule application: B-Mult"
            else errAt _p_ "Wrong rule application: B-Mult"
          | _ -> errAt _p_ "The number of premises is wrong: B-Mult")
       | _ -> errAt _p_ "The form of conclusion is wrong: B-Mult")
| {conc = _conc_; by = "B-Lt"; since = _derivs_; pos = _p_} ->
      (match _conc_ with
         AppBOp(Lt, Value_of_int i1, Value_of_int i2, Value_of_bool b3)  ->
         (match _derivs_ with
            [] ->
            if b3 = (i1 < i2)
            then if true then _conc_
                 else errAt _p_ "Wrong rule application: B-Lt"
            else errAt _p_ "Wrong rule application: B-Lt"
          | _ -> errAt _p_ "The number of premises is wrong: B-Lt")
       | _ -> errAt _p_ "The form of conclusion is wrong: B-Lt")
| {by=_name_; pos=_p_} -> errAt _p_ ("No such rule: " ^ _name_)

type in_judgment = In_EvalTo of exp | In_AppBOp of prim * value * value
let dummy = Lexing.dummy_pos
let deriv_stack = Stack.create ()

exception NoApplicableRule of in_judgment

let rec make_deriv = function
| In_EvalTo(Exp_of_int i) when true && 
       true  -> 
      let _subderivs_ = pop 0 deriv_stack [] in
      (match List.map (fun d -> d.conc) _subderivs_ with
        [] ->
        let _conc_ = EvalTo(Exp_of_int i, Value_of_int i) in 
        {conc = _conc_; by = "E-Int"; since = _subderivs_; pos = dummy})
| In_EvalTo(Exp_of_bool b) when true && 
       true  -> 
      let _subderivs_ = pop 0 deriv_stack [] in
      (match List.map (fun d -> d.conc) _subderivs_ with
        [] ->
        let _conc_ = EvalTo(Exp_of_bool b, Value_of_bool b) in 
        {conc = _conc_; by = "E-Bool"; since = _subderivs_; pos = dummy})
| In_EvalTo((If(e1, e2, e3))) when true && 
      let _d1_ = make_deriv (In_EvalTo(e1)) in Stack.push _d1_ deriv_stack;
      (match _d1_.conc with
          EvalTo(_, Value_of_bool b) ->
           if (b) then let _d2_ = make_deriv (In_EvalTo(e2)) in
           Stack.push _d2_ deriv_stack;
           (match _d2_.conc with
               EvalTo(_, v) ->
                 true 
             | _ -> for j = 1 to 2 do ignore (Stack.pop deriv_stack) done; false
             ) else (for j = 1 to 1 do ignore (Stack.pop deriv_stack) done; false)
        | _ -> for j = 1 to 1 do ignore (Stack.pop deriv_stack) done; false
        ) -> 
      let _subderivs_ = pop 2 deriv_stack [] in
      (match List.map (fun d -> d.conc) _subderivs_ with
        [EvalTo(_, Value_of_bool b); EvalTo(_, v)] ->
        if not (b) then err "Implementation error!" else
        let _conc_ = EvalTo((If(e1, e2, e3)), v) in 
        {conc = _conc_; by = "E-IfT"; since = _subderivs_; pos = dummy})
| In_EvalTo((If(e1, e2, e3))) when true && 
      let _d1_ = make_deriv (In_EvalTo(e1)) in Stack.push _d1_ deriv_stack;
      (match _d1_.conc with
          EvalTo(_, Value_of_bool b) ->
           if (not b) then let _d2_ = make_deriv (In_EvalTo(e3)) in
           Stack.push _d2_ deriv_stack;
           (match _d2_.conc with
               EvalTo(_, v) ->
                 true 
             | _ -> for j = 1 to 2 do ignore (Stack.pop deriv_stack) done; false
             ) else (for j = 1 to 1 do ignore (Stack.pop deriv_stack) done; false)
        | _ -> for j = 1 to 1 do ignore (Stack.pop deriv_stack) done; false
        ) -> 
      let _subderivs_ = pop 2 deriv_stack [] in
      (match List.map (fun d -> d.conc) _subderivs_ with
        [EvalTo(_, Value_of_bool b); EvalTo(_, v)] ->
        if not (not b) then err "Implementation error!" else
        let _conc_ = EvalTo((If(e1, e2, e3)), v) in 
        {conc = _conc_; by = "E-IfF"; since = _subderivs_; pos = dummy})
| In_EvalTo((BinOp(Plus, e1, e2))) when true && 
      let _d1_ = make_deriv (In_EvalTo(e1)) in Stack.push _d1_ deriv_stack;
      (match _d1_.conc with
          EvalTo(_, Value_of_int i1) ->
           let _d2_ = make_deriv (In_EvalTo(e2)) in
           Stack.push _d2_ deriv_stack;
           (match _d2_.conc with
               EvalTo(_, Value_of_int i2) ->
                let _d3_ = make_deriv (In_AppBOp(Plus, Value_of_int i1,
                                                 Value_of_int i2)) in
                Stack.push _d3_ deriv_stack;
                (match _d3_.conc with
                    AppBOp(_, _, _, Value_of_int i3) ->
                      true 
                  | _ -> for j = 1 to 3 do ignore (Stack.pop deriv_stack) done; false
                  )
             | _ -> for j = 1 to 2 do ignore (Stack.pop deriv_stack) done; false
             )
        | _ -> for j = 1 to 1 do ignore (Stack.pop deriv_stack) done; false
        ) -> 
      let _subderivs_ = pop 3 deriv_stack [] in
      (match List.map (fun d -> d.conc) _subderivs_ with
        [EvalTo(_, Value_of_int i1); EvalTo(_, Value_of_int i2);
        AppBOp(_, _, _, Value_of_int i3)] ->
        let _conc_ = EvalTo((BinOp(Plus, e1, e2)), Value_of_int i3) in 
        {conc = _conc_; by = "E-Plus"; since = _subderivs_; pos = dummy})
| In_EvalTo((BinOp(Minus, e1, e2))) when true && 
      let _d1_ = make_deriv (In_EvalTo(e1)) in Stack.push _d1_ deriv_stack;
      (match _d1_.conc with
          EvalTo(_, Value_of_int i1) ->
           let _d2_ = make_deriv (In_EvalTo(e2)) in
           Stack.push _d2_ deriv_stack;
           (match _d2_.conc with
               EvalTo(_, Value_of_int i2) ->
                let _d3_ = make_deriv (In_AppBOp(Minus, Value_of_int i1,
                                                 Value_of_int i2)) in
                Stack.push _d3_ deriv_stack;
                (match _d3_.conc with
                    AppBOp(_, _, _, Value_of_int i3) ->
                      true 
                  | _ -> for j = 1 to 3 do ignore (Stack.pop deriv_stack) done; false
                  )
             | _ -> for j = 1 to 2 do ignore (Stack.pop deriv_stack) done; false
             )
        | _ -> for j = 1 to 1 do ignore (Stack.pop deriv_stack) done; false
        ) -> 
      let _subderivs_ = pop 3 deriv_stack [] in
      (match List.map (fun d -> d.conc) _subderivs_ with
        [EvalTo(_, Value_of_int i1); EvalTo(_, Value_of_int i2);
        AppBOp(_, _, _, Value_of_int i3)] ->
        let _conc_ = EvalTo((BinOp(Minus, e1, e2)), Value_of_int i3) in 
        {conc = _conc_; by = "E-Minus"; since = _subderivs_; pos = dummy})
| In_EvalTo((BinOp(Mult, e1, e2))) when true && 
      let _d1_ = make_deriv (In_EvalTo(e1)) in Stack.push _d1_ deriv_stack;
      (match _d1_.conc with
          EvalTo(_, Value_of_int i1) ->
           let _d2_ = make_deriv (In_EvalTo(e2)) in
           Stack.push _d2_ deriv_stack;
           (match _d2_.conc with
               EvalTo(_, Value_of_int i2) ->
                let _d3_ = make_deriv (In_AppBOp(Mult, Value_of_int i1,
                                                 Value_of_int i2)) in
                Stack.push _d3_ deriv_stack;
                (match _d3_.conc with
                    AppBOp(_, _, _, Value_of_int i3) ->
                      true 
                  | _ -> for j = 1 to 3 do ignore (Stack.pop deriv_stack) done; false
                  )
             | _ -> for j = 1 to 2 do ignore (Stack.pop deriv_stack) done; false
             )
        | _ -> for j = 1 to 1 do ignore (Stack.pop deriv_stack) done; false
        ) -> 
      let _subderivs_ = pop 3 deriv_stack [] in
      (match List.map (fun d -> d.conc) _subderivs_ with
        [EvalTo(_, Value_of_int i1); EvalTo(_, Value_of_int i2);
        AppBOp(_, _, _, Value_of_int i3)] ->
        let _conc_ = EvalTo((BinOp(Mult, e1, e2)), Value_of_int i3) in 
        {conc = _conc_; by = "E-Mult"; since = _subderivs_; pos = dummy})
| In_EvalTo((BinOp(Lt, e1, e2))) when true && 
      let _d1_ = make_deriv (In_EvalTo(e1)) in Stack.push _d1_ deriv_stack;
      (match _d1_.conc with
          EvalTo(_, Value_of_int i1) ->
           let _d2_ = make_deriv (In_EvalTo(e2)) in
           Stack.push _d2_ deriv_stack;
           (match _d2_.conc with
               EvalTo(_, Value_of_int i2) ->
                let _d3_ = make_deriv (In_AppBOp(Lt, Value_of_int i1,
                                                 Value_of_int i2)) in
                Stack.push _d3_ deriv_stack;
                (match _d3_.conc with
                    AppBOp(_, _, _, Value_of_bool b3) ->
                      true 
                  | _ -> for j = 1 to 3 do ignore (Stack.pop deriv_stack) done; false
                  )
             | _ -> for j = 1 to 2 do ignore (Stack.pop deriv_stack) done; false
             )
        | _ -> for j = 1 to 1 do ignore (Stack.pop deriv_stack) done; false
        ) -> 
      let _subderivs_ = pop 3 deriv_stack [] in
      (match List.map (fun d -> d.conc) _subderivs_ with
        [EvalTo(_, Value_of_int i1); EvalTo(_, Value_of_int i2);
        AppBOp(_, _, _, Value_of_bool b3)] ->
        let _conc_ = EvalTo((BinOp(Lt, e1, e2)), Value_of_bool b3) in 
        {conc = _conc_; by = "E-Lt"; since = _subderivs_; pos = dummy})
| In_AppBOp(Plus, Value_of_int i1, Value_of_int i2) when true && 
      let i3 = i1 + i2 in   true
       -> 
      let _subderivs_ = pop 0 deriv_stack [] in
      (match List.map (fun d -> d.conc) _subderivs_ with
        [] ->
        let i3 = i1 + i2 in 
        let _conc_ = AppBOp(Plus, Value_of_int i1, Value_of_int i2,
                            Value_of_int i3) in 
        {conc = _conc_; by = "B-Plus"; since = _subderivs_; pos = dummy})
| In_AppBOp(Minus, Value_of_int i1, Value_of_int i2) when true && 
      let i3 = i1 - i2 in   true
       -> 
      let _subderivs_ = pop 0 deriv_stack [] in
      (match List.map (fun d -> d.conc) _subderivs_ with
        [] ->
        let i3 = i1 - i2 in 
        let _conc_ = AppBOp(Minus, Value_of_int i1, Value_of_int i2,
                            Value_of_int i3) in 
        {conc = _conc_; by = "B-Minus"; since = _subderivs_; pos = dummy})
| In_AppBOp(Mult, Value_of_int i1, Value_of_int i2) when true && 
      let i3 = i1 * i2 in   true
       -> 
      let _subderivs_ = pop 0 deriv_stack [] in
      (match List.map (fun d -> d.conc) _subderivs_ with
        [] ->
        let i3 = i1 * i2 in 
        let _conc_ = AppBOp(Mult, Value_of_int i1, Value_of_int i2,
                            Value_of_int i3) in 
        {conc = _conc_; by = "B-Mult"; since = _subderivs_; pos = dummy})
| In_AppBOp(Lt, Value_of_int i1, Value_of_int i2) when true && 
      let b3 = (i1 < i2) in   true
       -> 
      let _subderivs_ = pop 0 deriv_stack [] in
      (match List.map (fun d -> d.conc) _subderivs_ with
        [] ->
        let b3 = (i1 < i2) in 
        let _conc_ = AppBOp(Lt, Value_of_int i1, Value_of_int i2,
                            Value_of_bool b3) in 
        {conc = _conc_; by = "B-Lt"; since = _subderivs_; pos = dummy})
| j -> raise (NoApplicableRule j)
