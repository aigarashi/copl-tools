\documentclass[11pt]{jarticle}

\usepackage{a4full}
\usepackage{alltt,boxedminipage,url}

\title{\bf 導出チェッカコンパイラの概要}
\author{京都大学 大学院情報学研究科 知能情報学専攻 \\ 五十嵐 淳 \\
\url{igarashi@kuis.kyoto-u.ac.jp}}
\date{\today}

\markright{Draft of \today}

\begin{document}

\maketitle

\section{体系定義ファイル}
\label{sec:gamedef}

\begin{itemize}
\item コメントは (* *)
\item 3セクション (セクション名を [] で囲む)
  \begin{enumerate}
  \item BNF
  \item Judgments
  \item Rules
  \end{enumerate}
\end{itemize}

付帯条件に出現する変数は結論か前にある前提に出現するものでないといけな
い(ML6で強すぎる制限であることが発覚)．derivation generation のためには，
`\$i を使った式` か `\$o = \$i を使った式` の形でなければいけない．


\begin{figure}
  \begin{boxedminipage}{\textwidth}
\begin{alltt}
\input{nat.gm}
\end{alltt}
  \end{boxedminipage}
  \caption{サンプル nat.gm}
  \label{fig:nat.gm}
\end{figure}

\section{TODO}

\begin{itemize}
\item コードの整理
\item ゲーム用カテゴリ検査を emit 前にやる．
\item ゲーム用 parser, lexer 記述の負担軽減
\item 規則のモードチェックに失敗すると，導出生成を完全に諦めているが，
本当は，失敗した判断に依存しない部分に関しては導出生成をしてもよい．
\item 他の体系を書く
\item 規則名も文字列ではなくヴァリアント化？
\item make といっしょに自動テスト
\item gmファイル中に宣言された名前の衝突をチェック．
\item gm ファイルにフォーマット情報も追加できるようにする(特に QExp)．
\end{itemize}

\section{Wish list}

\begin{itemize}
\item BNF定義, 規則の plain text / TeX 出力
\begin{itemize}
\item 規則の TeX 出力(html用・Scheme 経由)はほぼ実装済
\end{itemize}
\item interactive checker / emacs のバッファから使えるようにする (proofgeneral?)
\item ブラウザから導出自動生成も使えるようにする．(要：終わらない導出生成の制御 ---
  timeout，導出の深さ?，stack overflow を待つのが簡単)
\item 導出に失敗する時に partial な導出を生成(「エラー」の specification?)
\end{itemize}

\section{ぶちあたった問題の数々}

\subsection{ML1}

\begin{itemize}
\item 真偽値を ML の bool と定義しようとしても，規則で定数(BNFセクショ
  ンに現われない)に言及できないので，ちょっと困る．(引用の中でないと true,
  false に言及できない．) それに伴って値の大小判定の規則が少し不自然．
\item [$\Rightarrow$] quote された ML 式を項としても書けるようにする？ (undone)

\item nat ゲームと違い，入力によっては導出がない場合がある(型エラーを出すプログラム)．
\item if (同じ形式の式にふたつ式がある)があるのでバックトラックも発生
\end{itemize}

\subsection{ML2}

\begin{itemize}
\item (解決済) 変数 lookup の付帯条件が，`output = 「input の演算」` の
  形式で書けない．回避策1:(`true = ($x = $y)`のように書く)はダメ．
  
モードをもっと真面目に見て生成するコードを変える必要がありそう．

根本的には，付帯条件が規則の適用条件にかかわっているから？
(足し算などとは根本的に違う点)
\item [$\Rightarrow$] 引用に output 変数が出るか(tbl を見ればわかる)によって，
変数束縛を出力するか，単なる bool 式を出すかをコントロールすることにした．

\item 早くもML1の parser のコードを再利用(継承？)したくなる．

\end{itemize}

\subsection{ML3}

特に問題なくできている．

\subsection{ML4}

特に問題なくできている．

\subsection{TypingML2}

if の then, else の型の同一性の検査に失敗するとMatch failure例外
が発生．マッチング条件に抜けがある？？ (ふたつの outvar の
同一性を要求する規則が初出？)

解決：\verb+emit_exp_of_premises+ の最後で等式を生成．

\subsection{TypingML4}

特に問題なし(？)．導出生成はできないゲーム．

\subsection{ML5}

特に問題なし．

\subsection{TypingML5}

特に問題なし．

\subsection{ML6}

\begin{itemize}
\item TC-Succ: = 形式の付帯条件の左辺が，続く前提に出現．
付帯条件中のメタ変数は既に現れていないと，導出チェックができない実装．
この場合は，付帯条件を全て後ろにまわせばよいが，付帯条件にしか
現われないメタ変数が現われるような規則はどう扱う？

導出チェックでも，= 形式の付帯条件は let にコンパイルする？

\item 付帯条件中のメタ変数の名前は基本的には alphanumeric でないと，
Buffer.add\_substitute が効かない．もしくは名前を \{\} で囲む必要あり．

\item マッチング判断は，値とパターンと(環境もしくは failure) の三項関係．
(マッチしない，という判断形式を別に導入すると，totality が失われる．)
\end{itemize}



\section{FAQ}

\begin{itemize}
\item [Q] Why not Twelf?
\item [A} MLの関数も呼びたいし．type theory 説明したくないし．
\end{itemize}


\end{document}

%%% Local Variables: 
%%% mode: latex
%%% End: 
