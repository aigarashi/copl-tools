#(;; Nat
					
  ; learn how to do addition
  (Nat "Z plus Z is Z")
  (Nat "Z plus S(S(Z)) is S(S(Z))")
  (Nat "S(S(Z)) plus Z is S(S(Z))")	
  (Nat "S(Z) plus S(S(S(Z))) is S(S(S(S(Z))))")	

  ; learn how to do multiplication
  (Nat "Z times S(S(Z)) is Z")
  (Nat "S(S(Z)) times Z is Z")
  (Nat "S(S(Z)) times S(Z) is S(S(Z))")
  (Nat "S(S(Z)) times S(S(Z)) is S(S(S(S(Z))))")

  ;; NatLt
  (NatLt1 "S(S(Z)) is less than S(S(S(Z)))")
  (NatLt2 "S(S(Z)) is less than S(S(S(Z)))")
  (NatLt3 "S(S(Z)) is less than S(S(S(Z)))")

  (NatLt1 "S(S(Z)) is less than S(S(S(S(S(Z)))))")
  (NatLt2 "S(S(Z)) is less than S(S(S(S(S(Z)))))")
  (NatLt3 "S(S(Z)) is less than S(S(S(S(S(Z)))))")

  ;; NatExp
  ; learn how to evaluate expressions
  (NatExp "Z + S(S(Z)) evalto S(S(Z))")
  (NatExp "S(S(Z)) + Z evalto S(S(Z))")
  (NatExp "S(Z) + S(Z) + S(Z) evalto S(S(S(Z)))")
  (NatExp "S(S(S(Z))) + S(S(Z)) * S(Z) evalto S(S(S(S(S(Z)))))")
  (NatExp "(S(S(Z)) + S(S(Z))) * Z evalto Z")
  (NatExp "Z * (S(S(Z)) + S(S(Z))) evalto Z")

  ;; ML1
  (ML1 "3 + 5 evalto 8")
  (ML1 "8 - 2 - 3 evalto 3")
  (ML1 "(4 + 5) * (1 - 10) evalto -81")
  (ML1 "if 4 < 5 then 2 + 3 else 8 * 8 evalto 5")
  (ML1 "3 + if -23 < -2 * 8 then 8 else 2 + 4 evalto 11")
  (ML1 "3 + (if -23 < -2 * 8 then 8 else 2) + 4 evalto 15")

  ;; ML2
  (ML2 "x = 3, y = 2 |- x evalto 3")
  (ML2 "x = true, y = 4 |- if x then y + 1 else y - 1 evalto 5")
  (ML2 "|- let x = 1 + 2 in x * 4 evalto 12")
  (ML2 "|- let x = 3 * 3 in let y = 4 * x in x + y evalto 45")
  (ML2 "x = 3 |- let x = x * 2 in x + x evalto 12")
  (ML2 "|- let x = let y = 3 - 2 in y * y in let y = 4 in x + y evalto 5")

  ;; ML3
  (ML3 "|- fun x -> x + 1 evalto ()[fun x -> x + 1]")
  (ML3 "|- let y = 2 in fun x -> x + y evalto (y=2)[fun x -> x + y]")
  (ML3 "|- let sq = fun x -> x * x in sq 3 + sq 4 evalto 25")
  (ML3 "|- let sm = fun f -> f 3 + f 4 in sm (fun x -> x * x) evalto 25")
  (ML3 "|- let max = fun x -> fun y -> if x < y then y else x in max 3 5 evalto 5")
  (ML3 "|- let a = 3 in let f = fun y -> y * a in let a = 5 in f 4 evalto 12")
  (ML3 "|- let twice = fun f -> fun x -> f (f x) in twice (fun x -> x * x) 2 evalto 16")
  (ML3 "|- let twice = fun f -> fun x -> f (f x) in twice twice (fun x -> x * x) 2 evalto 65536")
  (ML3 "|- let compose = fun f -> fun g -> fun x -> f (g x) in 
           let p = fun x -> x * x in
           let q = fun x -> x + 4 in
           compose p q 4 
           evalto 64")
  (ML3 "|- let s = fun f -> fun g -> fun x -> f x (g x) in
           let k = fun x -> fun y -> x in
           s k k 7
           evalto 7")

  ;; ML4
  (ML4 "|- let rec fact = fun n ->
             if n < 2 then 1 else n * fact (n - 1) in
           fact 3
           evalto 6")
  (ML4 "|- let rec fib = fun n -> if n < 3 then 1 else fib (n-1) + fib (n-2) in
           fib 5
           evalto 5")
  (ML4 "|- let rec sum = fun f -> fun n ->
             if n < 1 then 0 else f n + sum f (n - 1) in 
           sum (fun x -> x * x) 2
           evalto 5")
  (ML4 "|- let fact = fun self -> fun n ->
             if n < 2 then 1 else n * self self (n - 1) in
           fact fact 3
           evalto 6")
)